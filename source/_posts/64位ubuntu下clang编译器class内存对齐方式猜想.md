---
title: '64位ubuntu下clang编译器class内存对齐方式猜想'
date: 2017-1-11 17:33:20
tags: C++
---

最近在学习大神Lippman的著作-深度探索C++对象模型,总算是完美的解答了之前学习C++留下的诸多困惑.面向对象虽然很美,但是,背后的代价却是极其昂贵的.C++编译器的复杂度比C编译器的复杂度要提高好几个级别.当然,Lippman编写这本书的时候,操作系统还是32位时代,很多书中提出的思想,在现代64位编译器下面还可以得到验证.不得不服大神们当年高瞻远瞩.但是,对于class的内存排列问题,我测试了很多代码,按照书上的方法,实在没有找到合适的解释.
<!--more-->
今天和同学讨论了一下,估摸着,大概是这样的一个排列规则:

* 首先谈谈虚表指针,通过成员变量的指针偏移量看,clang应该是把虚表指针安放在对象的首部.同时,大小为8bit.

 * 同时,对于对齐补全,如果对象成员变量出现了8bit大小的变量(包括虚表指针),你们该类型的大小就会按照8bit进行对齐补全.
 
 * 对于char的处理也很有意思,如果char型声明的顺序靠拢在一起,那么他们会被捆绑着进行对齐补全.比如一个类按照8bit进行补全,如果声明中一个long变量上方有3个char,下方有5个char,那么连同这个long变量,将会占用24bit的大小.如果把这8个char紧靠着放在一起,这个类型会占用16bit的大小.
 
```cpp
class test{
public:

    char a;
    char b;
    char c;
    long d;
    char e;
    char f;
    char g;
    char h;
    char i;
    
};

```
 以上代码测试大小为24bit.
  
```cpp
class test{
public:

    char a;
    char b;
    char c;
    char e;
    char f;
    char g;
    char h;
    char i;
    long d;
    
};

```
 以上代码测试大小为16bit.
 
 所以,其实很多时候,良好的声明习惯,可以有效的降低内存开销.
 
 
